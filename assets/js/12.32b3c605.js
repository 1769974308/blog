(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{192:function(e,r,a){"use strict";a.r(r);var t=a(0),i=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"sql语句执行顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sql语句执行顺序","aria-hidden":"true"}},[e._v("#")]),e._v(" SQL语句执行顺序")]),e._v(" "),a("h2",{attrs:{id:"一、查询用到的关键词及顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、查询用到的关键词及顺序","aria-hidden":"true"}},[e._v("#")]),e._v(" 一、查询用到的关键词及顺序")]),e._v(" "),a("p",[e._v("select--from--where--group by--having--order by")]),e._v(" "),a("blockquote",[a("p",[e._v("select和from必选的，其他是可选的，关键词的执行顺序与sql语句书写顺序是不一致的，而是按下面的顺序来执行：from--on--join--where--group by--avg,sum..(聚合函数)--having--select--distinct--order by")])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("from :从哪个数据库表检索数据")])]),e._v(" "),a("li",[a("p",[e._v("where:过滤表中数据的条件")])]),e._v(" "),a("li",[a("p",[e._v("group by:从过滤出的数据分组")])]),e._v(" "),a("li",[a("p",[e._v("having:对已经分组的数据进行过滤的条件")])]),e._v(" "),a("li",[a("p",[e._v("select:查看结果集中的那个列")])]),e._v(" "),a("li",[a("p",[e._v("order by:按照怎么样的顺序来查看返回的数据")])])]),e._v(" "),a("h2",{attrs:{id:"二、from子句（执行顺序从后往前、从右到左）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、from子句（执行顺序从后往前、从右到左）","aria-hidden":"true"}},[e._v("#")]),e._v(" 二、from子句（执行顺序从后往前、从右到左）")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("最后面的表为驱动表，执行顺序为从后往前，所惟数据量少的表尽量放后，在FROM 子句中包含多个表的情况下,你必须选择记录条数最少的表作为基础表。如果有3 个以上的表连接查询, 那就需要选择交叉表(intersection table)作为基础表, 交叉表是指被其他表所引用的表。")])]),e._v(" "),a("li",[a("p",[e._v("多表连接时，使用表的别名并把别名前缀于每个Column上。可以减少解析的时间并减少那些由Column 歧义引起的语法错误.")])])]),e._v(" "),a("h2",{attrs:{id:"三、where子句（执行顺序自下而上、从右到左）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、where子句（执行顺序自下而上、从右到左）","aria-hidden":"true"}},[e._v("#")]),e._v(" 三、where子句（执行顺序自下而上、从右到左）")]),e._v(" "),a("ul",[a("li",[e._v("根据这个原理,表之间的连接必须写在其他Where 条件之前, 可以过滤掉最大数量记录的条件必须写在Where 子句的末尾。")])]),e._v(" "),a("h2",{attrs:{id:"四、group-by（执行顺序左往右分组）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、group-by（执行顺序左往右分组）","aria-hidden":"true"}},[e._v("#")]),e._v(" 四、group by（执行顺序左往右分组）")]),e._v(" "),a("ul",[a("li",[e._v("提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉。即在GROUP BY前使用WHERE来过虑，而尽量避免GROUP BY后再HAVING过滤")])]),e._v(" "),a("h2",{attrs:{id:"五、having-子句（很耗资源，尽量少用）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、having-子句（很耗资源，尽量少用）","aria-hidden":"true"}},[e._v("#")]),e._v(" 五、having 子句（很耗资源，尽量少用）")]),e._v(" "),a("ul",[a("li",[e._v("having 只会在检索出所有记录之后才对结果集进行过滤. 这个处理需要排序,总计等操作")]),e._v(" "),a("li",[e._v("on、where、having 这三个都可以加条件的子句中，on 是最先执行，where 次之，having 最后，因为on 是先把不符合条件的记录过滤后才进行统计，它就可以减少中间运算要处理的数据，按理说应该速度是最快的.")]),e._v(" "),a("li",[e._v("在多表联接查询时，on 比where 更早起作用。系统首先根据各个表之间的联接条件，把多个表合成一个临时表后，再由where 进行过滤，然后再计算，计算完后再由having 进行过滤。")])]),e._v(" "),a("h2",{attrs:{id:"六、select子句（少用-号，尽量取字段名称）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、select子句（少用-号，尽量取字段名称）","aria-hidden":"true"}},[e._v("#")]),e._v(" 六、select子句（少用*号，尽量取字段名称）")]),e._v(" "),a("ul",[a("li",[e._v("在解析的过程中, 会将依次转换成所有的列名, 这个工作是通过查询数据字典完成的, 使用列名意味着将减少消耗时间。")])]),e._v(" "),a("h2",{attrs:{id:"七、order-by子句（执行顺序为从左到右排序-很耗资源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、order-by子句（执行顺序为从左到右排序-很耗资源","aria-hidden":"true"}},[e._v("#")]),e._v(" 七、order by子句（执行顺序为从左到右排序,很耗资源")])])}],!1,null,null,null);r.default=i.exports}}]);